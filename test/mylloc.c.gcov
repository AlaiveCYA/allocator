        -:    0:Source:src/mylloc.c
        -:    1:#define _XOPEN_SOURCE 500
        -:    2:
        -:    3:#include <stdlib.h>
        -:    4:#include <stdbool.h>
        -:    5:#include <pthread.h>
        -:    6:#include <stdio.h>
        -:    7:#include <unistd.h>
        -:    8:#include <string.h>
        -:    9:#include "mylloc.h"
        -:   10:
        -:   11:
        -:   12:
        -:   13:struct Header
        -:   14:{
        -:   15:    struct Header* previousHeader;
        -:   16:    struct Header* nextHeader;
        -:   17:    unsigned int magicNumber;
        -:   18:    size_t size;
        -:   19:    bool isFree;
        -:   20:    const char* file;
        -:   21:    int line;
        -:   22:};
        -:   23:
        -:   24:static struct Stats stats = {0, 0, 0, 0, 0, 0};
        -:   25:
        -:   26:#define HEADER_SIZE sizeof(struct Header)
        -:   27:#define MIN_ALLOC_SIZE 64
        -:   28:#define MAGIC_NUMBER 0x272341
        -:   29:
        -:   30:static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
        -:   31:static bool isInitialized = false;
        -:   32:static struct Header *firstHeader = NULL;
        -:   33:static size_t currentAllocatedMemory = 0;
        -:   34:
        -:   35:static void programExit(void);
        -:   36:
        -:   37:
        -:   38:#ifdef __GNUC__
        -:   39:__attribute__((constructor))
        -:   40:#endif
        2:   41:int initializeAllocator(void){
        -:   42:
        2:   43:    if(isInitialized){
        1:   44:        return 0;
        -:   45:    }
        -:   46:
        1:   47:    firstHeader = (struct Header*) sbrk(HEADER_SIZE);
        1:   48:    if(firstHeader == (void*)-1){
    #####:   49:        return -1;
        -:   50:    }
        1:   51:    firstHeader->previousHeader = NULL;
        1:   52:    firstHeader->nextHeader = NULL;
        1:   53:    firstHeader->size = 0;
        1:   54:    firstHeader->isFree = true;
        1:   55:    isInitialized = true;
        1:   56:    firstHeader->magicNumber = MAGIC_NUMBER;
        1:   57:    firstHeader->file = NULL;
        1:   58:    firstHeader->line = 0;
        -:   59:
        1:   60:    atexit(programExit);
        -:   61:
        1:   62:    return 0;
        -:   63:}
        -:   64:
        -:   65:
        -:   66:
        7:   67:void* mylloc_full(size_t size_to_alloc, const char* file, int line){
        -:   68:
        7:   69:    if (!isInitialized)
        -:   70:    {
    #####:   71:        fprintf(stderr, "Error: Allocator not initialized\n");
    #####:   72:        exit(EXIT_FAILURE);
        -:   73:    }
        -:   74:    else
        -:   75:    {
        -:   76:
        7:   77:        stats.allocCalls++;
        -:   78:
        7:   79:        struct Header *currentHeader = firstHeader;
        7:   80:        struct Header *previousHeader = currentHeader->previousHeader;
        -:   81:
        7:   82:        pthread_mutex_lock(&mutex);
        -:   83:
        -:   84:        
        -:   85:
       14:   86:        while (currentHeader != NULL)
        -:   87:        {
       10:   88:            if (currentHeader->magicNumber != MAGIC_NUMBER)
        -:   89:            {
    #####:   90:                fprintf(stderr, "Error: Broken block\n");
    #####:   91:                fprintf(stderr, "File: %s\n", currentHeader->file);
    #####:   92:                fprintf(stderr, "Line: %d\n", currentHeader->line);
    #####:   93:                fprintf(stderr, "Size: %zu\n", currentHeader->size);
    #####:   94:                exit(EXIT_FAILURE);
        -:   95:            }
       10:   96:            if (currentHeader->isFree && currentHeader->size >= size_to_alloc)
        -:   97:            {
        3:   98:                if (currentHeader->size >= size_to_alloc + HEADER_SIZE + MIN_ALLOC_SIZE)
        -:   99:                {        
        -:  100:
        1:  101:                    struct Header *newHeader = (struct Header*)((char*)currentHeader + HEADER_SIZE + size_to_alloc);
        -:  102:
        1:  103:                    newHeader->previousHeader = currentHeader;
        1:  104:                    newHeader->nextHeader = currentHeader->nextHeader;
        1:  105:                    newHeader->size = currentHeader->size - size_to_alloc - HEADER_SIZE;
        1:  106:                    newHeader->isFree = true;
        1:  107:                    newHeader->file = file;
        1:  108:                    newHeader->line = line;
        1:  109:                    newHeader->magicNumber = MAGIC_NUMBER;
        -:  110:
        1:  111:                    currentHeader->nextHeader = newHeader;
        1:  112:                    currentHeader->size = size_to_alloc;
        -:  113:                }
        3:  114:                currentHeader->isFree = false;
        3:  115:                pthread_mutex_unlock(&mutex);
        -:  116:
        3:  117:                stats.totalAllocatedBytes += size_to_alloc;
        3:  118:                currentAllocatedMemory += currentHeader->size;
        3:  119:                stats.averageAllocatedBytes = stats.totalAllocatedBytes / stats.allocCalls;
        3:  120:                stats.peakMemory = stats.peakMemory < currentAllocatedMemory ? currentAllocatedMemory : stats.peakMemory;
        -:  121:
        3:  122:                return (void*)(currentHeader + 1);
        -:  123:                
        -:  124:            }
        -:  125:
        7:  126:            previousHeader = currentHeader;
        7:  127:            currentHeader = currentHeader->nextHeader;
        -:  128:        }
        -:  129:
        4:  130:        void* newBrk = sbrk(HEADER_SIZE + size_to_alloc);
        4:  131:        stats.sbrkCalls++;
        -:  132:
        4:  133:        if (newBrk == (void*)-1)
        -:  134:        {
    #####:  135:            pthread_mutex_unlock(&mutex);
        -:  136:
    #####:  137:            fprintf(stderr, "Error: Could not allocate memory\n");
    #####:  138:            exit(EXIT_FAILURE);
        -:  139:        }
        -:  140:
        4:  141:        struct Header *newHeader = (struct Header*)newBrk;
        -:  142:
        4:  143:        newHeader->previousHeader = previousHeader;
        4:  144:        newHeader->nextHeader = NULL;
        4:  145:        newHeader->size = size_to_alloc;
        4:  146:        newHeader->isFree = false;
        4:  147:        newHeader->file = file;
        4:  148:        newHeader->line = line;
        4:  149:        newHeader->magicNumber = MAGIC_NUMBER;
        -:  150:
        4:  151:        if (previousHeader != NULL)
        -:  152:        {
        4:  153:            previousHeader->nextHeader = newHeader;
        -:  154:        }
        -:  155:
        4:  156:        pthread_mutex_unlock(&mutex);
        -:  157:
        4:  158:        stats.totalAllocatedBytes += size_to_alloc;
        4:  159:        currentAllocatedMemory += newHeader->size;
        4:  160:        stats.peakMemory = stats.peakMemory < currentAllocatedMemory ? currentAllocatedMemory : stats.peakMemory;
        4:  161:        stats.averageAllocatedBytes = stats.totalAllocatedBytes / stats.allocCalls;
        -:  162:
        4:  163:        return (void*)(newHeader + 1);
        -:  164:        
        -:  165:    }
        -:  166:    
        -:  167:}
        -:  168:
        -:  169:
        6:  170:void myfree(void* block){
        -:  171:
        6:  172:    if(!isInitialized){
        -:  173:
    #####:  174:        fprintf(stderr, "Error: Allocator not initialized\n");
    #####:  175:        exit(EXIT_FAILURE);
        -:  176:    }
        -:  177:
        6:  178:    if (block == NULL)
        -:  179:    {
        1:  180:        return;
        -:  181:    }
        5:  182:    struct Header *header = (struct Header*)block - 1;
        -:  183:
        5:  184:    if (header->magicNumber != MAGIC_NUMBER)
        -:  185:    {
    #####:  186:        abort();
        -:  187:    }
        -:  188:
        5:  189:    if (header->isFree)
        -:  190:    {
    #####:  191:        fprintf(stderr, "Error: Block already freed\n");
    #####:  192:        exit(EXIT_FAILURE);
        -:  193:    }
        5:  194:    pthread_mutex_lock(&mutex);
        -:  195:
        5:  196:    header->isFree = true;
        5:  197:    currentAllocatedMemory -= header->size;
        5:  198:    if (header->previousHeader != NULL && header->previousHeader->isFree)
        -:  199:    {
        2:  200:        header->previousHeader->nextHeader = header->nextHeader;
        2:  201:        header->previousHeader->size += header->size + HEADER_SIZE;
        2:  202:        if (header->nextHeader != NULL)
        -:  203:        {
    #####:  204:            header->nextHeader->previousHeader = header->previousHeader;
        -:  205:        }
        2:  206:        header = header->previousHeader;
        -:  207:    }
        5:  208:    if (header->nextHeader != NULL && header->nextHeader->isFree)
        -:  209:    {
        1:  210:        header->size += header->nextHeader->size + HEADER_SIZE;
        1:  211:        header->nextHeader = header->nextHeader->nextHeader;
        1:  212:        if (header->nextHeader != NULL)
        -:  213:        {
    #####:  214:            header->nextHeader->previousHeader = header;
        -:  215:        }
        -:  216:    }
        5:  217:    pthread_mutex_unlock(&mutex);
        5:  218:    return;
        -:  219:}
        -:  220:
        1:  221:static void programExit(void){
        -:  222:
        1:  223:    if(!isInitialized){
    #####:  224:        return;
        -:  225:    }
        -:  226:
        1:  227:    struct Header *currentHeader = firstHeader;
        -:  228:
        -:  229:
        4:  230:    while (currentHeader != NULL)
        -:  231:    {
        3:  232:        if (!currentHeader->isFree)
        -:  233:        {
        2:  234:            stats.notFreedBlocks++;
        -:  235:        }
        3:  236:        currentHeader = currentHeader->nextHeader;
        -:  237:    }
        1:  238:    return;
        -:  239:}
        -:  240:
        1:  241:void dumpMemory(void) {
        1:  242:    struct Header *currentHeader = firstHeader;
        -:  243:
        4:  244:    while (currentHeader != NULL)
        -:  245:    {
        3:  246:        if (currentHeader->magicNumber != MAGIC_NUMBER)
        -:  247:        {
    #####:  248:            fprintf(stderr, "Error: Broken block\n");
    #####:  249:            fprintf(stderr, "File: %s\n", currentHeader->file);
    #####:  250:            fprintf(stderr, "Line: %d\n", currentHeader->line);
    #####:  251:            fprintf(stderr, "Size: %zu\n", currentHeader->size);
    #####:  252:            exit(EXIT_FAILURE);
        -:  253:        }
        3:  254:        if(currentHeader != firstHeader){
        2:  255:            fprintf(stderr, "{BLOCK start %p end %p, size %zu, free %d, allocated %s, %d}\n",
        -:  256:                (void*)currentHeader,
        2:  257:                (void*)((char*)currentHeader + currentHeader->size),
        -:  258:                currentHeader->size,
        2:  259:                currentHeader->isFree,
        -:  260:                currentHeader->file,
        -:  261:                currentHeader->line);
        -:  262:        }
        3:  263:        currentHeader = currentHeader->nextHeader;
        -:  264:    }
        1:  265:}
        -:  266:
        1:  267:void getStats(struct Stats* stats_out) {
        1:  268:    *stats_out = stats;
        1:  269:}
